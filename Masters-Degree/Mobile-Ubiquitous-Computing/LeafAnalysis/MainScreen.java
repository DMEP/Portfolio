package leafAnalysis;

/*
 * This file is the MainScreen.java, the main GUI that the user will be
 * presented and will contain all the future JInternalFrames GUI's. @author
 * Daniel Elstob @version 1.0 23-04-2015
 */
import java.awt.Polygon;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.*;
import java.util.*;
import javax.swing.*;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

public class MainScreen extends JFrame implements PropertyChangeListener {
    // <editor-fold defaultstate="collapsed" desc="Variables">
    public Hashtable speciesDatabase = null;
    public LeafViewer lv = null;
    public EdgeResults er = null;
    public EdgeView ev = null;
    public EdgeList esl = null;
    public LeafInfo li = null;
    public File cif = null;
    public File ccf = null;
    public File accessoryFile = null;
    public File databaseImages = null;
    public File databaseFile = null;
    public File wfile = null;
    public BufferedImage bi = null;
    public JFileChooser fc = null;
    public int iw, ih;
    private ProgressMonitor progressMonitorW = null;
    private ProgressMonitor progressMonitorO = null;
    private ProgressMonitor progressMonitorQ = null;
    private ProgressMonitor progressMonitor = null;
    private Task task = null;
    private WriteTask wtask = null;
    private OpenTask otask = null;
    private QueryTask qtask = null;
    public String taskType;
    public Hashtable added = new Hashtable();
    public Vector badFiles = new Vector();
    public String fileType = null;
    public BufferedWriter out = null;
    public String[] id = null;
    public double[][][] unknowns = null;
    public double[][][] unknownHarms = null;
    public CompareResults cr = null;
    public String[] imageFormats = {"jpg", "gif"};
    public String[] databaseFormats = {"odb"};
    public int nPoints = 100;
    public int nHarm = 40;
    public double convergence = 0.1;
    // </editor-fold>

    // Creates new form MainScreen.
    public MainScreen() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainDesktop = new javax.swing.JDesktopPane();
        mainMenu = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        Open = new javax.swing.JMenu();
        openDatabase = new javax.swing.JMenuItem();
        openImage = new javax.swing.JMenuItem();
        Save = new javax.swing.JMenu();
        saveDatabase = new javax.swing.JMenuItem();
        saveRenderedEdge = new javax.swing.JMenuItem();
        Database = new javax.swing.JMenu();
        newDatabase = new javax.swing.JMenuItem();
        updateDatabase = new javax.swing.JMenuItem();
        actionMenu = new javax.swing.JMenu();
        findEdge = new javax.swing.JMenuItem();
        renderImage = new javax.swing.JMenuItem();
        compareEdges = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Leaf Analysis");

        mainDesktop.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        mainMenu.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        fileMenu.setText("File");
        fileMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fileMenuActionPerformed(evt);
            }
        });

        Open.setText("Open");

        openDatabase.setText("Open Database");
        openDatabase.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openDatabaseActionPerformed(evt);
            }
        });
        Open.add(openDatabase);

        openImage.setText("Open Image");
        openImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openImageActionPerformed(evt);
            }
        });
        Open.add(openImage);

        fileMenu.add(Open);

        Save.setText("Save");

        saveDatabase.setText("Save Database");
        saveDatabase.setEnabled(false);
        saveDatabase.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveDatabaseActionPerformed(evt);
            }
        });
        Save.add(saveDatabase);

        saveRenderedEdge.setText("Save Rendered Edge");
        saveRenderedEdge.setEnabled(false);
        saveRenderedEdge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveRenderedEdgeActionPerformed(evt);
            }
        });
        Save.add(saveRenderedEdge);

        fileMenu.add(Save);

        Database.setText("Database");

        newDatabase.setText("New Database");
        newDatabase.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newDatabaseActionPerformed(evt);
            }
        });
        Database.add(newDatabase);

        updateDatabase.setText("Update Database");
        updateDatabase.setEnabled(false);
        updateDatabase.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                updateDatabaseActionPerformed(evt);
            }
        });
        Database.add(updateDatabase);

        fileMenu.add(Database);

        mainMenu.add(fileMenu);

        actionMenu.setText("Analyse");

        findEdge.setText("Find Edges");
        findEdge.setEnabled(false);
        findEdge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findEdgeActionPerformed(evt);
            }
        });
        actionMenu.add(findEdge);

        renderImage.setText("Rendered Edge");
        renderImage.setEnabled(false);
        renderImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                renderImageActionPerformed(evt);
            }
        });
        actionMenu.add(renderImage);

        compareEdges.setText("Compare");
        compareEdges.setEnabled(false);
        compareEdges.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                compareEdgesActionPerformed(evt);
            }
        });
        actionMenu.add(compareEdges);

        mainMenu.add(actionMenu);

        setJMenuBar(mainMenu);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainDesktop, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 900, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainDesktop, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 792, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    // Method to create a new database which can be saved or used to compare edges.
    private void newDatabaseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newDatabaseActionPerformed
        try {
            appendDatabase(false);
        } catch (Exception ex) {
        }
        this.saveDatabase.setEnabled(true);
        if (er.p != null) {
            this.compareEdges.setEnabled(true);
        }
    }//GEN-LAST:event_newDatabaseActionPerformed


    // Method for comparing edge(s) of current image against the database edges.
    private void compareEdgesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_compareEdgesActionPerformed
        try {
            progressMonitorO = null;
            progressMonitor = null;
            progressMonitorW = null;
            progressMonitorQ = new ProgressMonitor(this, "Querying database...", "", 0, 100);
            progressMonitorQ.setProgress(0);
            qtask = new QueryTask();
            qtask.addPropertyChangeListener(this);
            qtask.execute();
        } catch (Exception ex) {
            showMessage("Unable to perform identification!");
        }
    }//GEN-LAST:event_compareEdgesActionPerformed

    // <editor-fold defaultstate="collapsed" desc="Write Task">
    // The method that control the writing of information to the database 
    class WriteTask extends SwingWorker<Void, Void> {

        @Override
        public synchronized Void doInBackground() {
            Save.setVisible(false);
            int progress = 0;
            progress = 1;
            String path = wfile.getPath();
            try {
                if (fileType.equals("ri")) {
                    if (!Utils.getExtension(wfile).equals("gif")) {
                        path += ".gif";
                    }
                    Edging.renderBufferedImage(bi, "gif", path);
                } else {
                    if (!Utils.getExtension(wfile).equals(fileType)) {
                        System.out.println("The file type is " + fileType + " but the found file type is " + Utils.getExtension(wfile));
                        path += "." + fileType;
                    } else if (fileType.equals("odb")) {
                        Thread.sleep(1000);
                        int dbSize = 0;
                        String[] output;
                        if (esl == null) {
                            showMessage("No database is loaded. No database saved.");
                            return null;
                        }
                        while (esl.previous != null) {
                            esl = esl.previous;
                        }
                        while (esl.next != null) {
                            esl = esl.next;
                            dbSize++;
                        }
                        dbSize++;
                        while (esl.previous != null) {
                            esl = esl.previous;
                        }
                        output = new String[dbSize];
                        int cnt = 1;
                        progress = (int) (((double) cnt / (double) dbSize * 2) * (double) 100);
                        setProgress(progress);
                        output[0] = Edging.coordinateInformation(esl);
                        while (esl.next != null && !isCancelled()) {
                            esl = esl.next;
                            output[cnt] = Edging.coordinateInformation(esl);
                            progress = (int) (((double) cnt / (double) dbSize) * (double) 100) - 1; //assures progress bar not complete until final save
                            if (progress < 0) {
                                progress = 0;
                            }
                            setProgress(Math.min(progress, 100));
                            cnt++;
                        }
                        try {
                            out = new BufferedWriter(new FileWriter(path));
                            for (int i = 0; i < output.length && !isCancelled(); i++) {
                                out.write(output[i]);
                            }
                            out.close();
                        } catch (IOException e) {
                        }
                        setProgress(100);
                    } else {
                        showMessage("File type " + fileType + " not supported. No file saved.");
                    }
                }
            } catch (Exception ignore) {
                ignore.printStackTrace();
            }
            fileType = null;
            if (progressMonitorW != null) {
                progressMonitorW.close();
                progressMonitorW = null;
            }
            Save.setVisible(true);
            return null;
        }
        // Method to produce a messsage when database is succcessfully saved
        @Override
        public void done() {
            Toolkit.getDefaultToolkit().beep();
            if (wfile != null) {
                showMessage("Saving " + wfile.getPath() + " is complete.");
            }
            wfile = null;
        }
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Open Task">
    // This method will control the opening of existing database and ensuring 
    // that it is valid.
    class OpenTask extends SwingWorker<Void, Void> {
        int nE = 0;
        @Override
        public synchronized Void doInBackground() {
            int progress = 0;
            EdgeList el = new EdgeList();
            setProgress(progress);
            progress = 1;
            setProgress(progress);
            Open.setVisible(false);
            try {
                int tot = 1;
                BufferedReader in = null;
                tot = Utils.getLineCount(databaseFile.getPath());
                in = new BufferedReader(new FileReader(databaseFile));
                String line = in.readLine();
                if (line == null) {
                    return null;
                }
                if (line.length() <= 0) {
                    return null;
                }
                String temp = null;
                int cnt = 1;
                while (line != null && !isCancelled()) {
                    nE++;
                    el.taxon = line.substring(0, line.indexOf('\t')).trim();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.label = line.substring(0, line.indexOf('\t')).trim();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.part_name = line.substring(0, line.indexOf('\t')).trim();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.number = Integer.valueOf(line.substring(0, line.indexOf('\t')).trim()).intValue();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.dimensionality = Integer.valueOf(line.substring(0, line.indexOf('\t')).trim()).intValue();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.centered_normalized = Integer.valueOf(line.substring(0, line.indexOf('\t')).trim()).intValue();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.pixelArea = Integer.valueOf(line.substring(0, line.indexOf('\t')).trim()).intValue();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.pixelPerCentimeter = Double.valueOf(line.substring(0, line.indexOf('\t')).trim()).doubleValue();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.imageFile = line.substring(0, line.indexOf('\t')).trim();
                    line = line.substring(line.indexOf('\t') + 1).trim();
                    el.coordinates = new double[el.dimensionality][el.number];
                    for (int i = 0; i < el.number; i++) {
                        for (int t = 0; t < el.dimensionality; t++) {
                            if (line.indexOf('\t') >= 0) {
                                temp = line.substring(0, line.indexOf('\t')).trim();
                                el.coordinates[t][i] = Double.valueOf(temp).doubleValue();
                                line = line.substring(line.indexOf('\t') + 1).trim();
                            } else {
                                line = line.trim();
                                el.coordinates[t][i] = Double.valueOf(line).doubleValue();
                            }
                        }
                    }
                    cnt++;
                    progress = (int) (((double) cnt / (double) tot) * (double) 50);
                    setProgress(progress);
                    line = in.readLine();
                    if (line != null) {
                        el.next = new EdgeList();
                        el.next.previous = el;
                        el = el.next;
                    }
                }
            } catch (Exception ignore) {
                showMessage(ignore.getMessage() + " EXCEPTION CAUGHT");
            }
            esl = null;
            esl = new EdgeList();
            esl = el;
            if (el == null) {
                showMessage("Database file was opened, but no coordinates were readable.");
            } else {
                setProgress(50);
                speciesDatabase = null;
                speciesDatabase = new Hashtable();
                int totlvs = 0;
                while (el.previous != null) {
                    el = el.previous;
                    totlvs++;
                }
                int clvs = 0;
                while (el.next != null) {
                    Species t = (Species) speciesDatabase.get(el.taxon);
                    if (t == null) {
                        t = new Species(el.taxon, el.coordinates, nPoints, nHarm);
                    } else {
                        t.appendCoordinates(el.taxon, el.coordinates);
                    }
                    speciesDatabase.put(el.taxon, t);
                    el = el.next;
                    clvs++;
                    setProgress(50 + (int) (((double) clvs / (double) totlvs) * (double) 50));
                }
                Species t = (Species) speciesDatabase.get(el.taxon);
                if (t == null) {
                    t = new Species(el.taxon, el.coordinates, nPoints, nHarm);
                } else {
                    t.appendCoordinates(el.taxon, el.coordinates);
                }
                speciesDatabase.put(el.taxon, t);
                try {
                    prepareSpeciesDatabase(false);
                } catch (Exception ex) {
                    showMessage("There was an error parsing leaf coordinates");
                    ex.printStackTrace();
                }
                setProgress(100);
            }
            progressMonitorO.close();
            progressMonitorO = null;
            return null;
        }
        @Override
        public void done() {
            try {
                Toolkit.getDefaultToolkit().beep();
                if (esl == null) {
                    showMessage("Unable to load coordinates from " + databaseFile.getName() + ". Database is now empty.");
                    saveDatabase.setEnabled(false);
                } else {
                    showMessage("Database is now set to " + databaseFile.getName() + " with " + nE + " edges.");
                    Open.setVisible(true);
                    saveDatabase.setEnabled(true);
                    if (er != null) {
                        if (er.p != null) {
                            compareEdges.setEnabled(true);
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
                showMessage("Error: " + e.getMessage());
            }
        }
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Query Task">
    // This method will be used during the 'Compare' of the analysed image
    // with the database of edges.
    class QueryTask extends SwingWorker<Void, Void> {
        @Override
        public synchronized Void doInBackground() {
            int progress = 0;
            setProgress(progress);
            progress = 1;
            setProgress(progress);
            Open.setVisible(false);
            compareEdges.setVisible(false);
            try {
                unknowns = Edging.convertPolygons(er.p, nPoints, er.keep);
                unknownHarms = new double[unknowns.length][2][nPoints];
                int tlr = 0;
                double[][] rf1 = new double[2][nPoints];
                for (int i = 0; i < er.keep.length; i++) {
                    if (!er.keep[i]) {
                        tlr++;
                    }
                }
                for (int i = 0; i < er.p.length - tlr; i++) {
                    if (er.keep[i]) {
                        unknowns[i] = Edging.scalePoints(Edging.findCentroidDistance(unknowns[i]), unknowns[i]);
                        unknowns[i] = Edging.translateCoordinates(unknowns[i], Edging.findCentroid(unknowns[i]));
                        Edging.makeRadialFunction(unknowns[i], rf1);
                        unknownHarms[i] = Edging.getHarmonics(rf1, nHarm);
                    }
                }
                if (speciesDatabase == null || esl == null || unknowns == null || nHarm <= 0 || convergence < 0 || convergence > 1) {
                    showMessage("Identification failed");
                } else {
                    Set keys = speciesDatabase.keySet();
                    Iterator iter = keys.iterator();
                    Vector output = new Vector();
                    int tlr1 = 0;
                    for (int i = 0; i < er.keep.length; i++) {
                        if (er.keep[i]) {
                            tlr1++;
                        }
                    }
                    while (iter.hasNext()) {
                        Species t1 = (Species) speciesDatabase.get(iter.next());
                        double proDist = 0.0;
                        double fourDist = 0.0;
                        double combDist = 0.0;
                        for (int i = 0; i < unknowns.length; i++) {
                            if (er.keep[i]) {
                                {
                                    proDist += Edging.calculateProcrustesDistance(t1.aveCoords, unknowns[i], false);
                                    fourDist += Edging.calculateFourierDistance(unknownHarms[i][0], unknownHarms[i][1], t1.aveHarmonics[0], t1.aveHarmonics[1]);
                                    combDist += 9.4 * proDist + fourDist;
                                }
                            }
                        }
                        combDist /= (10 * tlr1);
                        System.out.println("Species: " + t1.name + " " + combDist + " " + fourDist + " " + proDist + " " + tlr1);
                        output.add(combDist + "\t" + t1.name);
                    }
                    id = null;
                    id = (String[]) output.toArray(new String[0]);
                    Arrays.sort(id);
                }
                progress = 100;
                setProgress(progress);
            } catch (Exception ignore) {
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);
                ignore.printStackTrace(pw);
                showMessage("Ran into a problem!");
            }
            System.out.println("Query complete");
            if (progressMonitorQ != null) {
                progressMonitorQ.close();
            }
            progressMonitorQ = null;
            return null;
        }
        @Override
        public void done() {
            Toolkit.getDefaultToolkit().beep();
            if (id == null) {
                showMessage("Search failed. No output list available.");
            } else if (unknowns == null) {
                showMessage("Search failed. Unknown edges not available.");
            }
            Open.setVisible(true);
            compareEdges.setVisible(true);
            if (cr != null) {
                cr.dispose();
                cr = null;
            }
            if (!(id == null) && !(unknowns == null)) {
                Hashtable taxa = new Hashtable();
                taxa = Edging.sortSSTEdgesByTaxon(speciesDatabase);
                cr = new CompareResults(id, unknowns, taxa);
                cr.setVisible(true);
                mainDesktop.add(cr);
                try {
                    cr.setSelected(true);
                } catch (java.beans.PropertyVetoException ignore) {
                }
            }
        }
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Task">
    // This method will allow a database to be created and ensure that one can
    // only be made if the requirements have been met
    class Task extends SwingWorker<Void, Void> {
        @Override
        public synchronized Void doInBackground() {
            Open.setVisible(false);
            int progress = 0;
            setProgress(progress);
            progress = 1;
            if (taskType.equals("generate database")) {
                String fileName = null;
                fileName = databaseImages.getPath();
                setProgress(progress);
                EdgeList tosl = null;
                try {
                    BufferedReader in = null;
                    in = new BufferedReader(new FileReader(databaseImages));
                    String line = in.readLine();
                    if (line == null) {
                        showMessage("Image list file " + fileName + " was empty.");
                        setProgress(100);
                        return null;
                    }
                    if (line.length() <= 0) {
                        showMessage("Image list file " + fileName + " was empty.");
                        setProgress(100);
                        return null;
                    }
                    String temp = null;
                    int tot = 1;
                    while (line != null) {
                        line = in.readLine();
                        tot++;
                    }
                    in.close();
                    in = new BufferedReader(new FileReader(databaseImages));
                    line = in.readLine(); // header
                    line = in.readLine(); // first line
                    if (line == null) {
                        showMessage("!Image list file " + fileName + " was empty.");
                        setProgress(100);
                        return null;
                    }
                    if (line.length() <= 0) {
                        showMessage("!Image list file " + fileName + " was empty.");
                        setProgress(100);
                        return null;
                    }
                    int cnt = 1;
                    while (line != null && !isCancelled()) {
                        String[] stuff = line.split("\t");
                        String iFile = stuff[0];
                        String species = stuff[1];
                        int expNum = Integer.parseInt(stuff[2]);
                        double pixS = Double.parseDouble(stuff[3]);
                        String inits = stuff[4];
                        String part = stuff[5];
                        int dim = Integer.parseInt(stuff[6]);
                        cnt++;
                        progress = (int) (((double) cnt / (double) tot) * (double) 100);
                        setProgress(Math.min(progress, 100));
                        line = in.readLine();
                    }
                    in.close();
                    setProgress(100);
                    if (esl == null) {
                        esl = new EdgeList();
                        esl = tosl;
                    } else {
                        while (tosl.previous != null) {
                            tosl = tosl.previous;
                        }
                        tosl.previous = esl;
                        esl.next = tosl;
                        while (esl.next != null) {
                            esl = esl.next;
                        }
                    }
                    if (esl == null) {
                        showMessage("Database file was opened, but no coordinates were readable.");
                    } else {
                        setProgress(0);
                        speciesDatabase = null;
                        speciesDatabase = new Hashtable();
                        int totlvs = 0;
                        while (esl.previous != null) {
                            esl = esl.previous;
                            totlvs++;
                        }
                        int clvs = 0;
                        while (esl.next != null) {
                            Species t = (Species) speciesDatabase.get(esl.taxon);
                            if (t == null) {
                                t = new Species(esl.taxon, esl.coordinates, nPoints, nHarm);
                            } else {
                                t.appendCoordinates(esl.taxon, esl.coordinates);
                            }
                            speciesDatabase.put(esl.taxon, t);
                            esl.coordinatesSST = t.edges.coordinatesSST;
                            esl = esl.next;
                            clvs++;
                            setProgress((int) (((double) clvs / (double) totlvs) * (double) 200));
                        }
                        //handle last one
                        Species t = (Species) speciesDatabase.get(esl.taxon);
                        if (t == null) {
                            t = new Species(esl.taxon, esl.coordinates, nPoints, nHarm);
                        } else {
                            t.appendCoordinates(esl.taxon, esl.coordinates);
                        }
                        speciesDatabase.put(esl.taxon, t);
                        try {
                            prepareSpeciesDatabase(false);
                        } catch (Exception ex) {
                            showMessage("There was an error parsing leaf coordinates");
                            ex.printStackTrace();
                        }
                        setProgress(100);
                    }
                    tosl = null;
                    Enumeration e = badFiles.elements();
                    String badf = new String();
                    while (e.hasMoreElements()) {
                        badf += (String) e.nextElement() + "\n";
                    }
                    showMessage("Database generation complete.\nDatabase now updated with edges in " + databaseImages.getName() + "\nThe following files did not load correctly.\nPlease please append these file coordinates to the database individually:\n" + badf);
                    Display tdf = new Display("Image files with problems", badf);
                    tdf.setVisible(true);
                    mainDesktop.add(tdf);
                    try {
                        tdf.setSelected(true);
                    } catch (java.beans.PropertyVetoException ignore) {
                    }
                    saveDatabase.setEnabled(true);
                    badFiles = null;
                    badFiles = new Vector();
                } catch (Exception ignore) {
                    ignore.printStackTrace();
                }
                progressMonitor.close();
                progressMonitor = null;
                return null;
            } else {
                try {
                    Random random = new Random();
                    Thread.sleep(1000);
                    while (progress < 100 && !isCancelled()) {
                        //Sleep for up to one second.
                        Thread.sleep(random.nextInt(1000));
                        //Make random progress.
                        progress += random.nextInt(10);
                        setProgress(Math.min(progress, 100));
                    }
                } catch (InterruptedException ignore) {
                }
                progressMonitor.close();
                progressMonitor = null;
                return null;
            }
        }

        @Override
        public void done() {
            Toolkit.getDefaultToolkit().beep();
            Open.setVisible(true);
        }
    }
    // </editor-fold>
    
    // Invoked when task's progress property changes.
    public void propertyChange(PropertyChangeEvent evt) {
        if ("progress" == evt.getPropertyName()) {
            int progress = (Integer) evt.getNewValue();
            String message =
                    String.format("Completed %d%%\n", progress);
            if (progressMonitor != null) {
                progressMonitor.setProgress(progress);
                progressMonitor.setNote(message);
                if (taskType.equals("generate database") && (progressMonitor.isCanceled() || task.isDone())) {
                    Toolkit.getDefaultToolkit().beep();
                }
                if (progressMonitor.isCanceled()) {
                    task.cancel(true);
                }
            } else if (progressMonitorW != null) {
                progressMonitorW.setProgress(progress);
                progressMonitorW.setNote(message);
                if (progressMonitorW.isCanceled() || wtask.isDone()) {
                    Toolkit.getDefaultToolkit().beep();
                }
                if (progressMonitorW.isCanceled()) {
                    wtask.cancel(true);
                }
            } else if (progressMonitorO != null) {
                progressMonitorO.setProgress(progress);
                progressMonitorO.setNote(message);
                if (progressMonitorO.isCanceled() || otask.isDone()) {
                    Toolkit.getDefaultToolkit().beep();
                }
                if (progressMonitorO.isCanceled()) {
                    otask.cancel(true);
                }
            } else if (progressMonitorQ != null) {
                progressMonitorQ.setProgress(progress);
                progressMonitorQ.setNote(message);
                if (progressMonitorQ.isCanceled() || qtask.isDone()) {
                    Toolkit.getDefaultToolkit().beep();
                }
                if (progressMonitorQ.isCanceled()) {
                    qtask.cancel(true);
                }
            }
        }
    }

    private void openDatabaseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openDatabaseActionPerformed
        databaseFile = getTextFile(new FileNameExtensionFilter("Edges Database", "odb"));
        if (databaseFile != null) {
            esl = null;
            progressMonitorO = new ProgressMonitor(this, "Opening database. It may take a few minutes to process the leaf coordinates.", "", 0, 100);
            progressMonitorO.setProgress(0);
            otask = new OpenTask();
            otask.addPropertyChangeListener(this);
            otask.execute();
        } else {
            showMessage("No database file opened.");
        }
    }//GEN-LAST:event_openDatabaseActionPerformed

    private void prepareSpeciesDatabase(boolean recreateDatabase) throws Exception {
        if (recreateDatabase) {
            speciesDatabase = null;
            speciesDatabase = new Hashtable();
            while (esl.previous != null) {
                esl = esl.previous;
            }
            int cnt = 0;
            while (esl.next != null) {
                cnt++;
                System.out.println("Working on leaf " + cnt + ": " + esl.taxon);
                Species t = (Species) speciesDatabase.get(esl.taxon);
                if (t == null) {
                    t = new Species(esl.taxon, esl.coordinates, this);
                } else {
                    t.appendCoordinates(esl.taxon, esl.coordinates);
                }
                speciesDatabase.put(esl.taxon, t);
                esl = esl.next;
            }
            //handle last one
            Species t = (Species) speciesDatabase.get(esl.taxon);
            if (t == null) {
                t = new Species(esl.taxon, esl.coordinates, this);
            } else {
                t.appendCoordinates(esl.taxon, esl.coordinates);
            }
            speciesDatabase.put(esl.taxon, t);
        }
        Set keys = speciesDatabase.keySet();
        Iterator iter = keys.iterator();
        while (iter.hasNext()) {
            Species t1 = (Species) speciesDatabase.get(iter.next());
            t1.prepareCoordinates();
            speciesDatabase.put(t1.name, t1);
        }
    }

    public void setInformation(EdgeList tosl) {
        if (tosl == null) {
            return;
        }
        er = new EdgeResults(this);
        li = new LeafInfo();
        int cnt = 0;
        while (tosl.previous != null) {
            tosl = tosl.previous;
        }
        while (tosl.next != null) {
            tosl = tosl.next;
            cnt++;
        }
        cnt++;
        li.dimensionality = tosl.dimensionality;
        li.txtDimensionality.setText(Integer.toString(li.dimensionality));
        li.initials = tosl.label;
        li.txtInitials.setText(li.initials);
        li.part = tosl.part_name;
        li.txtPOF.setText(li.part);
        li.pixelsPerCentimeter = tosl.pixelPerCentimeter;
        li.txtPPC.setText(Double.toString(li.pixelsPerCentimeter));
        li.nEdges = cnt;
        li.txtNOE.setText(Integer.toString(cnt));
        li.imageFilePath = tosl.imageFile;
        li.txtIF.setText(li.imageFilePath);
        li.species = tosl.taxon;
        li.txtSpecies.setText(li.species);
        er.p = new Polygon[cnt];
        er.pArea = new int[er.p.length];
        er.cSize = new double[er.p.length];
        er.keep = new boolean[er.p.length];
        for (int i = 0; i < er.p.length; i++) {
            er.keep[i] = true;
        }
        int i = 0;
        while (tosl.previous != null) {
            //   er.p[i] = Edging.getPolygon(tosl.coordinates);
            er.pArea[i] = tosl.pixelArea;
            er.cSize[i] = tosl.centroidDistance;
            i++;
            tosl = tosl.previous;
        }
        //  er.p[i] = Edging.getPolygon(tosl.coordinates);
        if (er.p != null) {
            er.setEdgeInformation();
            er.setButtons();
            er.lblEdgeNumber.setText("Total edges: " + er.p.length);
        }
    }

    private void updateDatabaseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_updateDatabaseActionPerformed
        try {
            if (cif != null) {
                String file = (String) added.get(cif.getPath());
                if (file == null) {
                    appendDatabase(true);
                    added.put(cif.getPath(), "present");
                } else if (file.length() == 0) {
                    appendDatabase(true);
                    added.put(cif.getPath(), "present");
                } else {
                    showMessage("Edges have already been added.");
                }
            } else if (ccf != null) {
                String file = (String) added.get(ccf.getPath());
                if (file == null) {
                    appendDatabase(true);
                    added.put(ccf.getPath(), "present");
                } else if (file.length() == 0) {
                    appendDatabase(true);
                    added.put(ccf.getPath(), "present");
                } else {
                    showMessage("Edges have already been added.");
                }
            } else {
                showMessage("Edges have already been added.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        this.saveDatabase.setEnabled(true);
        if (er.p != null) {
            this.compareEdges.setEnabled(true);
        }
    }//GEN-LAST:event_updateDatabaseActionPerformed

    private void appendDatabase(boolean append) throws Exception {
        if (er.p == null) {
            showMessage("Database action failed. Edges are not defined.");
        } else if (li == null) {
            showMessage("Database action failed. Edge information must be defined.");
            openFileInformationWindow();
        } else if (li.species == null || li.txtIF == null || li.nEdges <= 0 || li.part == null || li.initials == null || li.pixelsPerCentimeter <= 0) {
            showMessage("Database action failed. Edge information must be defined.");
            openFileInformationWindow();
        }
        double[][] coordinates = Edging.extractCoordinates(er.p[0]);
        double centroidDistance = 0;
        int pixelArea = 0;
        if (!append) {
            esl = null;
            speciesDatabase = null;
        }
        if (esl != null) {
            while (esl.next != null) {
                esl = esl.next;
            }
        }
        String species = li.species;
        String imageText = li.txtIF.getText();
        double pixelSize = Double.parseDouble(li.txtPPC.getText());
        String initials = li.txtInitials.getText();
        String part = li.txtPOF.getText();
        int normCent = 0;
        int dimensionality = li.dimensionality;
        EdgeList nosl = null;
        for (int i = 0; i < er.p.length; i++) {
            if (er.keep[i]) {
                System.out.println("Appending leaf " + i + " of species " + species + " to database.");
                coordinates = Edging.extractCoordinates(er.p[i]);
                if (er.cSize[i] <= 0) {
                    centroidDistance = Edging.findCentroidDistance(coordinates);
                } else {
                    centroidDistance = er.cSize[i];
                }
                if (er.pArea[i] <= 0) {
                    pixelArea = Edging.findArea(er.p[i]);
                } else {
                    pixelArea = er.pArea[i];
                }
                if (esl == null) {
                    esl = new EdgeList(species, imageText, centroidDistance, pixelArea, pixelSize, (initials + i), er.p[i].npoints, part, 0, dimensionality, coordinates);
                    Species t = new Species(species, esl.coordinates, this);
                    speciesDatabase = new Hashtable();
                    speciesDatabase.put(species, t);
                } else {
                    nosl = new EdgeList(species, imageText, centroidDistance, pixelArea, pixelSize, (initials + i), er.p[i].npoints, part, 0, dimensionality, coordinates);
                    esl.next = nosl;
                    nosl.previous = esl;
                    esl = esl.next;
                    if (speciesDatabase == null) {
                        throw new Exception("Species database has not been initialized for some reason.");
                    }
                    Species t = (Species) speciesDatabase.get(species);
                    if (t == null) {

                        t = new Species(species, esl.coordinates, this);

                    } else {
                        t.appendCoordinates(species, esl.coordinates);
                    }
                    t.prepareCoordinates();
                    speciesDatabase.put(species, t);
                }
            }
        }
        if (!append) {
            showMessage("Database has been created. Prior database replaced.");
        } else {
            showMessage("Database has been updated.");
        }
    }

    private void saveRenderedEdgeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveRenderedEdgeActionPerformed
        fileType = "ri";
        saveFile();
        fileType = null;
    }//GEN-LAST:event_saveRenderedEdgeActionPerformed

    private void saveDatabaseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveDatabaseActionPerformed
        fileType = "odb";
        saveFile();
        fileType = null;
    }//GEN-LAST:event_saveDatabaseActionPerformed

    private void showMessage(String text) {
        JOptionPane.showMessageDialog(this, text);
    }

    private String makeEdgeText() {
        String out = new String();
        for (int i = 0; i < er.p.length; i++) {
            if (er.keep[i]) {
                out += li.species + "\t"
                        + li.initials + "\t"
                        + li.part + "\t"
                        + er.p[i].npoints + "\t"
                        + li.dimensionality
                        + "\t0\t"
                        + Edging.findArea(er.p[i]) + "\t"
                        + li.pixelsPerCentimeter + "\t"
                        + li.imageFilePath + "\t";
                for (int j = 0; j < er.p[i].npoints; j++) {
                    out += er.p[i].xpoints[j] + "\t" + er.p[i].ypoints[j] + "\t";
                }
                out += "\n";
            }
        }
        return out;
    }

    private String generateEdgeFileText() {
        if (er.p == null) {
            showMessage("Saving file failed. Edges are not defined.");
            return new String();
        } else if (li == null) {
            showMessage("Saving file failed. Edge information must be defined.");
            openFileInformationWindow();
            return new String();
        } else if (li.species == null || li.txtIF == null || li.nEdges <= 0 || li.part == null || li.initials == null || li.pixelsPerCentimeter <= 0) {
            showMessage("Saving file failed. Edge information must be defined.");
            openFileInformationWindow();
            return new String();
        }
        return makeEdgeText();
    }

    public void writeFile(String file, String[] content) {
        try {
            BufferedWriter out = new BufferedWriter(new FileWriter(file));
            for (int i = 0; i < content.length; i++) {
                out.write(content[i]);
            }
            out.close();
        } catch (IOException e) {
        }
    }

    public void writeFile(String file, String content) {
        try {
            BufferedWriter out = new BufferedWriter(new FileWriter(file));
            out.write(content);
            out.close();
        } catch (IOException e) {
        }
    }

    public File[] getTextFiles(FileFilter ff) {
        fc = new JFileChooser();
        fc.setMultiSelectionEnabled(true);
        //Add a custom file filter and disable the default
        //(Accept All) file filter.
        if (ff != null) {
            fc.setFileFilter(ff);
            fc.setAcceptAllFileFilterUsed(false);
        }
        //Show it.
        int returnVal = fc.showDialog(this, "Open");
        //Process the results.
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            return (fc.getSelectedFiles());
        } else {
        }
        //Reset the file chooser for the next time it's shown.
        fc.setVisible(true);
        return null;
    }

    public File getTextFile(FileFilter ff) {
        fc = new JFileChooser();
        //Add a custom file filter and disable the default
        //(Accept All) file filter.
        if (ff != null) {
            fc.setFileFilter(ff);
            fc.setAcceptAllFileFilterUsed(false);
        }
        //Show it.
        int returnVal = fc.showDialog(this, "Open");
        //Process the results.
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            return (fc.getSelectedFile());
        } else {
        }
        //Reset the file chooser for the next time it's shown.
        fc.setVisible(true);
        return null;
    }

    public void saveFile() {
        fc = new JFileChooser();
        int returnVal = fc.showSaveDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            wfile = fc.getSelectedFile();
            progressMonitorW = new ProgressMonitor(this, "Saving file", "", 0, 100);
            progressMonitorW.setProgress(0);
            taskType = "write database";
            wtask = new WriteTask();
            wtask.addPropertyChangeListener(this);
            wtask.execute();
            showMessage("Beep will sound when file saving is complete.");
            wtask = null;
        }
        fc = null;
    }

    private void renderImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_renderImageActionPerformed
        bi = Edging.renderEdgeImage(er.p, iw, ih, er.keep);
        openRenderedEdgesWindow();
        saveRenderedEdge.setEnabled(true);
    }//GEN-LAST:event_renderImageActionPerformed

    public void openRenderedEdgesWindow() {
        ImageIcon icon = new ImageIcon(bi);
        if (ev != null) {
            ev.dispose();
            ev = null;
        }
        ev = new EdgeView();
        ev.renderedEdges.setIcon(icon);
        ev.setVisible(true);
        mainDesktop.add(ev);
        try {
            ev.setSelected(true);
        } catch (java.beans.PropertyVetoException e) {
        }
    }

    public void openImage(File file) {
        ImageIcon icon = new ImageIcon(file.getPath());
        if (lv != null) {
            lv.dispose();
            lv = null;
        }
        lv = new LeafViewer();
        lv.lblImage.setIcon(icon);
        lv.setVisible(true);
        mainDesktop.add(lv);
        try {
            lv.setSelected(true);
        } catch (java.beans.PropertyVetoException e) {
        }
    }

    public void openImage() {
        ImageIcon icon = null;
        icon = new ImageIcon(cif.getPath());
        if (icon != null) {
            if (lv != null) {
                lv.dispose();
                lv = null;
            }
            lv = new LeafViewer();
            lv.lblImage.setIcon(icon);
            lv.setVisible(true);
            mainDesktop.add(lv);
            try {
                lv.setSelected(true);
            } catch (java.beans.PropertyVetoException e) {
            }
        } else {
            showMessage("Could not make image icon");
        }
    }

    private void openEdgeViewWindow() {
        try {
            if (cif != null) {
                if (er != null) {
                    er.dispose();
                }
                er = null;
                er = new EdgeResults(Edging.findCoordinates(cif), this);
            }
            if (er != null) {
                er.setVisible(true);
                mainDesktop.add(er);
                try {
                    er.setSelected(true);
                } catch (java.beans.PropertyVetoException e) {
                }
                this.renderImage.setEnabled(true);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void openFileInformationWindow() {
        try {
            if (li != null) {
                li.dispose();
            } else if (li == null) {
                li = new LeafInfo();
            }
            if (cif != null) {
                li.imageFilePath = cif.getPath();
            }
            if (er != null) {
                li.nEdges = er.keptEdge();
                li.dimensionality = 2;
                li.txtDimensionality.setText(Integer.toString(li.dimensionality));
                li.txtNOE.setText(Integer.toString(li.nEdges));
                li.txtIF.setText(li.imageFilePath);
                li.setVisible(true);
                mainDesktop.add(li);
                try {
                    li.setSelected(true);
                } catch (java.beans.PropertyVetoException e) {
                }
            } else {
                this.showMessage("Error finding outlines. Please make sure objects are on clean white background.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void findEdgeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findEdgeActionPerformed
        openEdgeViewWindow();
        openFileInformationWindow();
        if (er != null) {
            //saveCoordinates.setEnabled(true);
            renderImage.setEnabled(true);
            updateDatabase.setEnabled(true);
            newDatabase.setEnabled(true);
        }
        if (esl != null) {
            if (er.p != null) {
                this.compareEdges.setEnabled(true);
            }
        }
        if (ev != null) {
            ev.dispose();
            ev = null;
        }
    }//GEN-LAST:event_findEdgeActionPerformed

    private void fileMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fileMenuActionPerformed
// TODO add your handling code here:
    }//GEN-LAST:event_fileMenuActionPerformed

    private void openImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openImageActionPerformed
        ImageIcon icon = null;
        ImageChooser ic = new ImageChooser(this);
        if (cif != null) {
            iw = ImageInfo.imageWidth(cif.getPath());
            ih = ImageInfo.imageHeight(cif.getPath());
        }
        if (cif != null) {
            findEdge.setEnabled(true);
            saveRenderedEdge.setEnabled(false);
            renderImage.setEnabled(false);
            updateDatabase.setEnabled(false);
            newDatabase.setEnabled(false);
            this.compareEdges.setEnabled(false);
            if (li != null) {
                li.dispose();
                li = null;
            }
            if (er != null) {
                er.dispose();
                er = null;
            }
            if (ev != null) {
                ev.dispose();
                ev = null;
            }
            if (bi != null) {
                bi = null;
            }
        }
    }//GEN-LAST:event_openImageActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            // Set cross-platform Java L&F (also called "Metal")
            UIManager.setLookAndFeel("com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel");
        } catch (UnsupportedLookAndFeelException e) {
            // handle exception
        } catch (ClassNotFoundException e) {
            // handle exception
        } catch (InstantiationException e) {
            // handle exception
        } catch (IllegalAccessException e) {
            // handle exception
        }
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                MainScreen mS = new MainScreen();
                mS.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                mS.setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu Database;
    private javax.swing.JMenu Open;
    private javax.swing.JMenu Save;
    private javax.swing.JMenu actionMenu;
    private javax.swing.JMenuItem compareEdges;
    private javax.swing.JMenu fileMenu;
    public javax.swing.JMenuItem findEdge;
    private javax.swing.JDesktopPane mainDesktop;
    private javax.swing.JMenuBar mainMenu;
    private javax.swing.JMenuItem newDatabase;
    private javax.swing.JMenuItem openDatabase;
    private javax.swing.JMenuItem openImage;
    private javax.swing.JMenuItem renderImage;
    private javax.swing.JMenuItem saveDatabase;
    private javax.swing.JMenuItem saveRenderedEdge;
    private javax.swing.JMenuItem updateDatabase;
    // End of variables declaration//GEN-END:variables
}
